---
title: UML SPECIFICATIONS
date: 2019-05-28
categories: DEV
tags:
- dev
- uml
---
UML 2.0 defines ++thirteen types of diagrams++, divided into ++three categories++: Six diagram types represent static application structure; three represent general types of behavior; and four represent different aspects of interactions:
<div class="list">
      <ul style="padding-left:0;list-style-type:square;">
      <li style="margin: 0 0 10px 15px;"><strong>Structure Diagrams</strong> include the Class Diagram, Object Diagram,
      Component Diagram, Composite Structure Diagram, Package Diagram, and Deployment Diagram.&nbsp;</li>
      <li style="margin: 0 0 10px 15px;"><strong>Behavior Diagrams</strong> include the Use Case Diagram (used by some
      methodologies during requirements gathering); Activity
      Diagram, and State Machine Diagram.&nbsp;</li>
      <li style="margin: 0 0 10px 15px;"><strong>Interaction Diagrams,</strong> all derived from the more general Behavior
      Diagram, include the Sequence Diagram, Communication Diagram, Timing
      Diagram, and Interaction Overview Diagram.</li>
      </ul>
</div>

**结构型UML图包括：**

- 类图（Class Diagram）
- 组件图（Component Diagram）
- 复合结构图（Composite Structure Digram）
- 部署图（Deployment Diagram）
- 部署图（Deployment Diagram
- 对象图（Object Diagram）
- 包图（Package Diagram）
- 轮廓图（Profile Diagram）

**行为型UML 图包括：**
- 活动图（Activity Diagram）
- 通信图（Communication Diagram）
- 交互概览图（Interaction Overview Diagram）
- 序列图（Sequence  Diagram）
- 状态图（state Diagram）
- 时限图（Timing Diagram）
- 用例图(Use Case Diagram)

---
###### Class Diagram

类与类之间的关系包括泛化（Generalization）、实现（Realization）、关联（Association）、依赖（Dependency）、组合（Composition）和聚集（Aggregate）

**泛化（Generalization）**

泛化是一种一般与特殊、一般与具体之间关系的描述，具体描述建立在一般描述的基础之上，并对其进行了扩展。在java中用来表示继承的关系。


- 相当于java 语言中的 **extends** 
- 表示方法：用**实线空心三角箭**头表示。
```
public class Queue<T>{

   private int capacity = 1000;
   private ReentrantLock takeLock;
   private ReentrantLock putLock;

   public T take(){
     T element = null;
     return element;
   }

   public void put(T element){
     
  }
}
```

**实现（Realization）**

实现是一种**类**与**接口**的关系，表示类是接口所有特征和行为的实现，在程序中一般通过类实现接口来描述

- 表示方法：**空心三角形箭头**的**虚线**，++实现类指向接口++

**依赖（Dependency）**

是一种使用的关系，即一个类的实现需要另一个类的协助。

- java中，方法参数需要传入另一个类的对象，就表示依赖这个类。代码中一般指由局部变量，函数参数，返回值建立的对于其他对象的调用关系
- 表示方法：**虚线与箭头**(非空心非实心箭头)，类A指向类B。


**关联（Association）** 

表示类与类之间的联接,它使一个类知道另一个类的属性和方法，这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的。关联关系从代码的层次可以理解为一个类拥有某个实例变量，该变量的类型为另外一个类，

- java中一个类的全局变量引用了另一个类，就表示关联了这个类
- 表示方法：**实线与箭头**，类A指向类B，++也可以没有箭头，没有箭头代表是双向的++。
```
public class Person  {
  private Set<MobilePhone> mobilePhones = new HashSet<MobilePhone>();
}

class MobilePhone{

  private Person owner = null;
 }
```
**聚集（Aggregate）**

聚合关联关系的一种特例，是强的关联关系。聚合是整体和个体之间的关系，即has-a的关系，整体与个体可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。程序中聚合和关联关系是一致的，只能从语义级别来区分；

- 表示方法：尾部为**空心菱形**的**实线箭头**（也可以没箭头），类A指向类B

**组合（Composition）**

组合也是关联关系的一种特例。组合是一种整体与部分的关系，即contains-a的关系，比聚合更强。部分与整体的生命周期一致，整体的生命周期结束也就意味着部分的生命周期结束，组合关系不能共享。程序中组合和关联关系是一致的，只能从语义级别来区分。

- 表示方法：尾部为**实心菱形**的**实线箭头**（也可以没箭头），类A指向类B
```
public class LocationExample{

   public static void main(String[] args){
  
   LocationService ls = new LocationService();
   Location location = ls.getCurrentLocation();

   // 其他代码

   }
}

class LocationService{
   private final GPSClientDevice gpsClient = new GPSClientDevice();

   public Location getCurrentLocation(){
     Location aLocation;
     aLcation gpsClient.retrieveLocation();
     return aLocation;
   }
}

class GPSClientDevice{

  public Location retrieveLocation(){
     Location aLocation = new Location();
     
 // 其他代码
    return aLocation;
  }
} 

class Location{
  // 其他代码
}
```