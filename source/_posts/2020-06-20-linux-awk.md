---
title: Linux AWK
date: 2020-06-20
categories: Linux
tags:
- linux
- awk
---

>refer to: https://www.tutorialspoint.com/awk/awk_operators.htm

AWK follows a simple workflow − **Read, Execute, and Repeat**. The following diagram depicts the workflow of AWK −

![image](https://www.tutorialspoint.com/awk/images/awk_workflow.jpg)

##### Read
AWK reads a line from the input stream (file, pipe, or stdin) and stores it in memory.

##### Execute
All AWK commands are applied sequentially on the input. By default AWK execute commands on every line. We can restrict this by providing patterns.

##### Repeat
This process repeats until the file reaches its end.

### Program Structure

**BEGIN block**

The syntax of the BEGIN block is as follows −
```
BEGIN {awk-commands}
```
The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.

**Body Block**

The syntax of the body block is as follows −
```
awk '/pattern/ {awk-commands}'
```
The body block applies AWK commands on every input line. By default, AWK executes commands on every line. We can restrict this by providing patterns. Note that there are no keywords for the Body block.

**END Block**

The syntax of the END block is as follows −
```
END {awk-commands}
```
The END block executes at the end of the program. END is an AWK keyword and hence it must be in upper-case. Please note that this block is optional.


#### Basic Syntax

AWK is simple to use. We can provide AWK commands either directly from the command line or in the form of a text file containing AWK commands.

```
awk [options] file ...
//or
awk [options] -f file ....
```

**AWK Standard Options**

AWK supports the following standard options which can be provided from the command line.

- The `-v` option

This option assigns a value to a variable. It allows assignment before the program execution. The following example describes the usage of the -v option.
    
```
[lance]$ awk -v name=Jerry 'BEGIN{printf "Name = %s\n", name}'

//output
Name = Jerry
```
- The `--dump-variables[=file]` option

It prints a sorted list of global variables and their final values to file. The default file is `awkvars.out`.

```
[lance]$ awk --dump-variables ''
[lance]$ cat awkvars.out 
```
- The --posix option

This option turns on strict POSIX compatibility, in which all common and gawk-specific extensions are disabled.

#### Basic example
- Counting and Printing Matched Pattern

```
[lance]$ awk '/a/{++cnt} END {print "Count = ", cnt}' marks.txt
```
In this example, we increment the value of counter when a pattern match succeeds and we print this value in the END block. Note that unlike other programming languages, there is no need to declare a variable before using it.

- Printing Lines with More than 18 Characters
```
[lance]$ awk 'length($0) > 18' marks.txt

//output
3) Shyam   Biology   87
4) Kedar   English   85
```
AWK provides a built-in length function that returns the length of the string. $0 variable stores the entire line and in the absence of a body block, default action is taken, i.e., the print action. Hence, if a line has more than 18 characters, then the comparison results true and the line gets printed.

### Built in Variables
AWK provides several built-in variables. They play an important role while writing AWK scripts.

#### Standard AWK variables

##### `ARGC`
It implies the number of arguments provided at the command line.
```
[jerry]$ awk 'BEGIN {print "Arguments =", ARGC}' One Two Three Four

//output
5
```
But why AWK shows 5 when you passed only 4 arguments? Just check the following example to clear your doubt.

##### `ARGV`
It is an array that stores the command-line arguments. The array's valid index ranges from ==0 to ARGC-1==.
```
[lance]$ awk 'BEGIN { 
   for (i = 0; i < ARGC - 1; ++i) { 
      printf "ARGV[%d] = %s\n", i, ARGV[i] 
   } 
}' one two three four

//output
ARGV[0] = awk
ARGV[1] = one
ARGV[2] = two
ARGV[3] = three
```

##### `CONVFMT`
It represents the output format number and its default value is `%.6g`.
```
[jerry]$ awk 'BEGIN { print "Conversion Format =", CONVFMT }'
```

##### `ENVIRON`
It is an associative array of environment variables.
```
[jerry]$ awk 'BEGIN { print ENVIRON["USER"] }'
```

##### `FILENAME`
It represents the current file name.
```
[jerry]$ awk 'END {print FILENAME}' marks.txt

```

##### `FS`
It represents the (input) field separator and its default value is space. You can also change this by using -F command line option.
```
[jerry]$ awk 'BEGIN {print "FS = " FS}' | cat -vte
```

##### `NF`
It represents the number of fields in the current record. For instance, the following example prints only those lines that contain more than two fields.
```
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NF > 2'
```

##### `NR`
It represents the number of the current record. For instance, the following example prints the record if the current record number is less than three.
```
[jerry]$ echo -e "One Two\nOne Two Three\nOne Two Three Four" | awk 'NR < 3'
```

##### `FNR`
It is similar to NR, but relative to the current file. It is useful when AWK is operating on multiple files. Value of FNR resets with new file.
```
[jerry]$ awk 'BEGIN {print "OFMT = " OFMT}'
```

##### `OFMT` 
It represents the output format number and its default value is %.6g.
```
[jerry]$ awk 'BEGIN {print "OFMT = " OFMT}'
```

##### `OFS` 
It represents the output field separator and its default value is space.
##### `ORS` 
It represents the output record separator and its default value is newline.
##### `RLENGTH`
It represents the length of the string matched by match function. AWK's match function searches for a given string in the input-string.
```
[jerry]$ awk 'BEGIN { if (match("One Two Three", "re")) { print RLENGTH } }'
```

##### `RS`
It represents (input) record separator and its default value is newline.
```
$ awk 'BEGIN {print "RS = " RS}' | cat -vte

//Output
RS = $
$
```
##### `RSTART`
It represents the first position in the string matched by match function.
```
[jerry]$ awk 'BEGIN { if (match("One Two Three", "Thre")) { print RSTART } }'

//output
9
```

##### `SUBSEP`
It represents the separator character for array subscripts and its default value is \034.
```
[jerry]$ awk 'BEGIN { print "SUBSEP = " SUBSEP }' | cat -vte

//output
SUBSEP = ^\$
```

##### `$0`
It represents the entire input record.

##### `$n`
It represents the nth field in the current record where the fields are separated by FS.

#### GNU AWK Specific Variables

##### `ARGIND`
It represents the index in ARGV of the current file being processed.







