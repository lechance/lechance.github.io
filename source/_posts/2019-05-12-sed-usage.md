---
title: sed usage
date: 2019-5-12
categories: Linux
tags:
- linux
- sed
---
### Print
```
sed -n '1,3p' data
sed -n '/second/p' data
sed -n '/second/,4p' data
sed -n '2,/last/p' data
sed -n '/data/,/last/p' data
sed -n '1,4{=;p}' data

sed -n '/^#/!p' /etc/passwd
```
### Add
```
//add
sed '2a drink tea' data     //add `drink tea` string
sed '/world/s/^/Li /' myfile //mathing `world` then append `Li` to begin.

//insert
sed '2i drink tea' data     

sed 's/^/Start /' data  //add `Start` at begin of line
sed 's/$/End /' data
```
### Delete
```
sed '2,5d' data
sed '3,$d' data
sed -e '/^#/d' -e '/^$/d' /etc/vsftpd/vsftpd.conf

sed '/root/d' data  //search and delete
sed '/^#/!d' data //delete line which not begin with #
```
### Substitute

```
sed '2,5c No 2-5 number' data   //将第2-5行的内容取代成为『No 2-5 number』呢？
sed -i 's/static/dhcp/' test    //substitute `static` with `dhcp`
sed -i '/root/{s/bash/nologin/;s/0/1/g}' test     //#匹配root的行，把bash替换成nologin，且把0替换成1  
```
### Search and Execute command
```
sed -n '/root/{s/bash/blueshell/;p}' data
```



<div style="margin:260px"></div>
---

### **sed** is a Stream Editor : It filters and transforms text.

https://www.gnu.org/software/sed/manual/sed.html#Overview

#### Syntax

```
sed OPTIONS... [SCRIPT] [INPUTFILE...]
```

If you do not specify ***INPUTFILE***, or if INPUTFILE is "**-**", **sed** filters the contents of the standard input. The script is actually the first non-option parameter, which sed specially considers a script and not an input file if and only if none of the other options specifies a script to be executed (that is, if neither of the -e and -f options is specified).
```
sed 's/hello/world/' input.txt > output.txt
```

#### Options
Options|Description
---|---
-n, --quiet, --silent|	Suppress automatic printing of pattern space.
-e script, --expression=script	|	Add the script script to the commands to be executed.
-f script-file, --file=script-file	|	Add the contents of script-file to the commands to be executed.
--follow-symlinks	|	Follow symlinks when processing in place.
-i[SUFFIX], --in-place[=SUFFIX]|		Edit files in place (this makes a backup with file extension SUFFIX, if SUFFIX is supplied).
-l N, --line-length=N	|	Specify the desired line-wrap length, N, for the "l" command.
--POSIX|		Disable all GNU extensions.
-r, --regexp-extended|		Use extended regular expressions in the script.
-s, --separate|		Consider files as separate rather than as a single continuous long stream.
-u, --unbuffered|		Load minimal amounts of data from the input files and flush the output buffers more often.
--help|		Display a help message, and exit.
--version|		Output version information, and exit.


### `[addr]X[options]`

X is a single-letter sed command. [addr] is an optional line address. If [addr] is specified, the command X will be executed only on the matched lines. [addr] can be a single line number, a regular expression, or a range of lines (see sed addresses). Additional [options] are used for some sed commands.

##### Print(query)

The following example prints all input until a line starting with the word ‘foo’ is found. If such line is found, sed will terminate with exit status 42. If such line was not found (and no other error occurred), sed will exit with status 0. **/^foo/** is a ++regular-expression++ address. **q** is the ++quit command++. **42** is the ++command option++.
```
sed '/^foo/q42' input.txt > output.txt
```

##### Delete


```
sed '30,35d' input.txt > output.txt
```
##### Add(append)

##### Modify

#### sed commands summary

The following commands are supported in GNU sed. Some are standard POSIX commands, while other are GNU extensions. Details and examples for each command are in the following sections. **(Mnemonics) are shown in parentheses**.
```sh
a text  //Append text after a line.
b label //Branch unconditionally to label. The label may be omitted, in which case the next cycle is started.
c text  //Replace (change) lines with text.
c text  //Replace (change) lines with text (alternative syntax).
d   //Delete the pattern space; immediately start next cycle.
D   //If pattern space contains newlines, delete text in the pattern space up to the first newline, and restart cycle with the resultant pattern space, without reading a new line of input.
e   //Executes the command that is found in pattern space and replaces the pattern space with the output; a trailing newline is suppressed.
e command   //Executes command and sends its output to the output stream. The command can run across multiple lines, all but the last ending with a back-slash.
F   //(filename) Print the file name of the current input file (with a trailing newline).
g   //Replace the contents of the pattern space with the contents of the hold space.
G   //Append a newline to the contents of the pattern space, and then append the contents of the hold space to that of the pattern space.
h   //(hold) Replace the contents of the hold space with the contents of the pattern space.
H   //Append a newline to the contents of the hold space, and then append the contents of the pattern space to that of the hold space.
i text  //insert text before a line.
l   //Print the pattern space in an unambiguous form.
n   //(next) If auto-print is not disabled, print the pattern space, then, regardless, replace the pattern space with the next line of input. If there is no more input then sed exits without processing any more commands.
N   //Add a newline to the pattern space, then append the next line of input to the pattern space. If there is no more input then sed exits without processing any more commands.
p   //Print the pattern space.
P   //Print the pattern space, up to the first <newline>.
q[exit-code]    //(quit) Exit sed without processing any more commands or input.
Q[exit-code]    //(quit) This command is the same as q, but will not print the contents of pattern space. Like q, it provides the ability to return an exit code to the caller.
r filename  //Reads file filename.
R filename  //Queue a line of filename to be read and inserted into the output stream at the end of the current cycle, or when the next input line is read.
s/regexp/replacement/[flags]    //(substitute) Match the regular-expression against the content of the pattern space. If found, replace matched string with replacement.
t label   //(test) Branch to label only if there has been a successful substitution since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.
T label   //(test) Branch to label only if there have been no successful substitutions since the last input line was read or conditional branch was taken. The label may be omitted, in which case the next cycle is started.
v [version]      //(version) This command does nothing, but makes sed fail if GNU sed extensions are not supported, or if the requested version is not available.
w filename       //Write the pattern space to filename.
W filename      //Write to the given filename the portion of the pattern space up to the first newline
y/src/dst/      //Transliterate any characters in the pattern space which match any of the source-chars with the corresponding character in dest-chars.
z   //(zap) This command empties the content of pattern space.
#   //A comment, until the next newline.
{ cmd ; cmd ... }   //Group several commands together.
=   //Print the current input line number (with a trailing newline).
: label     //Specify the location of label for branch commands (b, t, T).
```
#### The s Command
The s command (as in substitute) is probably the most important in sed and has a lot of different options. The syntax of the s command is` ‘s/regexp/replacement/flags’.`

Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.

For details about regexp syntax see [Regular Expression Addresses](https://www.gnu.org/software/sed/manual/sed.html#Regexp-Addresses).